import React, { useState, useRef, useEffect } from 'react';
import { Chessboard } from 'react-chessboard';
import { Chess, SQUARES } from 'chess.js';
import './App.css';

// --- Constants ---
const CENTER_SQUARES = ['e4', 'd4', 'e5', 'd5'];
const BLUNDER_THRESHOLD_CP = -100; // Blunder if opponent's score becomes >= +100 cp

// --- Helper Function ---
function formatScore(score, type) { if(type==='cp'){const e=(score/100).toFixed(2);return(e>0?'+':'')+e;}else if(type==='mate'){return 'M'+score;}return '?'; }

// --- React Component ---
function App() {
    // --- State & Refs ---
    const chess = useRef(new Chess()); const [boardFen, setBoardFen] = useState(chess.current.fen()); const [fenInput, setFenInput] = useState(boardFen); const [fenError, setFenError] = useState(''); const worker = useRef(null); const analyzingFenRef = useRef(null); const fenAfterCandidateRef = useRef(null); const [engineLoaded, setEngineLoaded] = useState(false); const [engineMessage, setEngineMessage] = useState('Loading engine...'); const isAnalyzingRef = useRef(false); const isCheckingCandidateResponseRef = useRef(false); const [isAnalyzing, setIsAnalyzing] = useState(false); const [analysisPVs, setAnalysisPVs] = useState([]); const analysisPVsRef = useRef(analysisPVs); const [analysisEval, setAnalysisEval] = useState(''); const [analysisProgress, setAnalysisProgress] = useState(''); const [selectedLineIndex, setSelectedLineIndex] = useState(null); const [currentMoveInLine, setCurrentMoveInLine] = useState(0); const [attackedPieces, setAttackedPieces] = useState([]); const [controlledCenterSquares, setControlledCenterSquares] = useState([]); const [candidateMoveInput, setCandidateMoveInput] = useState(''); const [userMoveVisualization, setUserMoveVisualization] = useState(null); const [opponentResponses, setOpponentResponses] = useState([]); const [isCheckingCandidateResponse, setIsCheckingCandidateResponse] = useState(false); const [candidateMoveError, setCandidateMoveError] = useState('');

    useEffect(() => { analysisPVsRef.current = analysisPVs; }, [analysisPVs]);
    // useEffect(() => { console.log("[State Update] analysisPVs changed:", analysisPVs); }, [analysisPVs]);
    useEffect(() => { console.log("[State Update] opponentResponses changed:", opponentResponses); }, [opponentResponses]);

    // --- Load Stockfish Engine ---
    useEffect(() => {
        console.log('[Effect EngineLoad] Setting up...'); const workerPath = '/stockfish-nnue-16.js'; let localWorker;
        try { localWorker = new Worker(workerPath); console.log("[Effect EngineLoad] Worker created:", localWorker);
            localWorker.onmessage = (event) => {
                if (localWorker !== worker.current) { console.log("[Worker Message] Ignored (stale)"); return; } // Correct return for stale worker
                const message = event.data;

                // ---> Make sure there is NO 'return;' right here <---
                if (typeof message !== 'string') {
                     console.log("[Worker Message] Ignored (non-string):", message);
                     return; // Ignore non-string messages, this return is OK
                }
                // console.log('[Stockfish message]:', message); // Log is fine here if needed

                // --- Process string messages ---
                if (message.startsWith('info') && isAnalyzingRef.current) { /* ... process main info ... */ let d=null,n=null,st=null,sv=null,p=null,lid=null;const pts=message.split(' ');let psi=-1;for(let i=0;i<pts.length;i++){const pt=pts[i];const np=pts[i+1];if(pt==='depth'&&np)d=parseInt(np,10);else if(pt==='nodes'&&np)n=parseInt(np,10);else if(pt==='multipv'&&np)lid=parseInt(np,10);else if(pt==='score'&&pts[i+1]&&pts[i+2]){st=pts[i+1];sv=parseInt(pts[i+2],10);i+=2;}else if(pt==='pv'){psi=i+1;break;}} if(psi!==-1)p=pts.slice(psi).join(' ');const pgt=`Depth: ${d||'N/A'}, Nodes: ${n||'N/A'}`; setAnalysisProgress(cp=>cp!==pgt?pgt:cp); if(lid!==null&&st!==null&&sv!==null&&p!==null){const cfen=analyzingFenRef.current;if(!cfen){console.error(`[Info Main] CRITICAL: Ref NULL`);return;}let t4pv='w';try{t4pv=(new Chess(cfen)).turn();}catch(e){}const adjSV=(t4pv==='b')?-sv:sv;const fs=formatScore(adjSV,st);const upv=p;setAnalysisPVs(cpv=>{const npvs=[...cpv];const idx=npvs.findIndex(i=>i.lineId===lid);const pd={lineId:lid,score:fs,uci_pv:upv,start_fen:cfen};let c=false;if(idx>-1){if(JSON.stringify(npvs[idx])!==JSON.stringify(pd)){npvs[idx]=pd;c=true;}}else{npvs.push(pd);c=true;}if(c){npvs.sort((a,b)=>a.lineId-b.lineId);return npvs.slice(0,3);}return cpv;});if(lid===1){setAnalysisEval(ce=>ce!==fs?fs:ce);}}}
                 else if (message.startsWith('info') && isCheckingCandidateResponseRef.current) { /* ... process opponent response info ... */ console.log("[Opponent Resp] Info:",message.substring(0,100)+'...');let pv=null,lid=null,st=null,sv=null;const pts=message.split(' ');let psi=-1;for(let i=0;i<pts.length;i++){if(pts[i]==='score'&&pts[i+1]&&pts[i+2]){st=pts[i+1];sv=parseInt(pts[i+2],10);i+=2;}else if(pts[i]==='multipv'&&pts[i+1])lid=parseInt(pts[i+1],10);else if(pts[i]==='pv'){psi=i+1;break;}}if(psi!==-1)pv=pts.slice(psi).join(' ');if(lid!==null&&pv&&(lid===1||lid===2)){const uM=pv.split(' ');const oppUCI=uM[0];if(oppUCI){const fenChk=fenAfterCandidateRef.current;if(!fenChk)return;try{const gR=new Chess(fenChk);let mD=null;let mR=null;if(oppUCI.length>=4&&oppUCI.length<=5){mD={from:oppUCI.substring(0,2),to:oppUCI.substring(2,4),promotion:oppUCI.length===5?oppUCI.substring(4,5):undefined};mR=gR.move(mD,{verbose:true});}if(mR){const isC=mR.flags.includes('c');const isK=mR.san.includes('+')||mR.san.includes('#');let tAC='w';try{tAC=(new Chess(fenChk)).turn();}catch(e){}const adjS=(tAC==='b'&&sv!==null)?-sv:sv;const fmS=(st!==null&&adjS!==null)?formatScore(adjS,st):'?';const isB=(st==='cp'&&sv!==null&&sv>=-BLUNDER_THRESHOLD_CP);const rd={lineId:lid,from:mR.from,to:mR.to,san:mR.san,score:fmS,isBlunder:isB,isCapture:isC,isCheck:isK};console.log(`[Opponent Resp] Parsed ${lid}:`,rd);setOpponentResponses(cr=>{const n=[...cr];const i=n.findIndex(r=>r.lineId===lid);if(i>-1)n[i]=rd;else n.push(rd);n.sort((a,b)=>a.lineId-b.lineId);return n;});}else{console.warn(`[Opponent Resp] Invalid UCI '${oppUCI}' on FEN '${fenChk}'.`);}}catch(e){console.error(`[Opponent Resp] Error sim '${oppUCI}':`,e);}}}}
                 else if (message.startsWith('bestmove')) { /* ... (existing bestmove handler) ... */ console.log("Rcv bestmove:",message);let fin=false;if(isAnalyzingRef.current){console.log("Main finished:",message);isAnalyzingRef.current=false;fin=true;}else if(isCheckingCandidateResponseRef.current){console.log("Opp check finished:",message);isCheckingCandidateResponseRef.current=false;fin=true;}if(fin){console.log("[Bestmove] Updating state...");setIsAnalyzing(false);setIsCheckingCandidateResponse(false);setEngineMessage('Engine ready.');setAnalysisProgress('');}}
                 else if (message.startsWith('uciok')) { /*...*/ setEngineLoaded(true);setEngineMessage('Engine ready. Init...');sendEngineCommand('setoption name Use NNUE value true');sendEngineCommand('setoption name Threads value 4');sendEngineCommand('setoption name Hash value 128');sendEngineCommand('isready');}
                 else if (message.startsWith('readyok')) { /*...*/ setEngineMessage('Engine initialized.');performStaticAnalysis(chess.current.fen());}
                 else if (message.startsWith('info')) { console.warn(`[OnMessage] Unhandled INFO (an=${isAnalyzingRef.current}, chk=${isCheckingCandidateResponseRef.current}): ${message.substring(0,100)}...`);}
            };
            localWorker.onerror = (e)=>{/*...*/if(localWorker!==worker.current)return;console.error('WORKER ONERROR');const m=e?(e.message||'No msg'):'No err';setEngineMessage(`Worker error:${m}.`);setEngineLoaded(false);isAnalyzingRef.current=false;isCheckingCandidateResponseRef.current=false;setIsAnalyzing(false);setIsCheckingCandidateResponse(false);if(worker.current===localWorker){worker.current.terminate();worker.current=null;}else{localWorker.terminate();}};
            worker.current = localWorker; sendEngineCommand('uci');
        } catch (error) { /*...*/ console.error('[Effect EngineLoad] Error:',error);setEngineMessage(`Error creating worker: ${error.message}.`);setEngineLoaded(false);}
        return () => { /*...*/ console.log("[Effect EngineLoad] Cleanup for:",localWorker);if(localWorker){localWorker.postMessage('quit');setTimeout(()=>{if(localWorker)localWorker.terminate();},100);}if(worker.current===localWorker){console.log("[Effect EngineLoad] Nullifying ref.");worker.current=null;setEngineLoaded(false);setEngineMessage('Engine unloaded.');isAnalyzingRef.current=false;isCheckingCandidateResponseRef.current=false;}else{console.log("[Effect EngineLoad] Cleanup: ref changed.");}};
    }, []); // End Engine Load useEffect

    // --- Other Effects (Spacebar, PV Board Update) ---
    useEffect(() => { /* ... spacebar ... */ const h=(e)=>{if(e.target.matches('input'))return;if(e.key===' '){const i=selectedLineIndex;const a=isAnalyzing;const p=analysisPVsRef.current;const c=(i!==null&&!a);if(c){e.preventDefault();const l=p[i];const v=(l&&l.uci_pv&&l.start_fen);if(v){const m=l.uci_pv.split(' ').length;setCurrentMoveInLine(x=>Math.min(x+1,m));}}}};window.addEventListener('keydown',h);return()=>{window.removeEventListener('keydown',h);}; }, [selectedLineIndex, isAnalyzing]);
    useEffect(() => { /* ... pv board update ... */ if(selectedLineIndex===null||isAnalyzing)return;const d=analysisPVs[selectedLineIndex];const sf=d?.start_fen;const up=d?.uci_pv;if(!d||!up||!sf)return;let sa=[];try{const g=new Chess(sf);const ui=up.split(' ');const uc=ui.slice(0,currentMoveInLine);for(const um of uc){if(um.length>=4&&um.length<=5){const md={from:um.substring(0,2),to:um.substring(2,4),promotion:um.length===5?um.substring(4,5):undefined};const mr=g.move(md);if(mr)sa.push(mr.san);else throw new Error(`Inv ${um}`);}else throw new Error(`Inv UCI ${um}`);}}catch(e){console.error("Err conv step:",e);return;}try{const rg=new Chess(sf);let ma=true;for(const sm of sa){if(!rg.move(sm)){ma=false;break;}}if(ma){const ff=rg.fen();if(boardFen!==ff)setBoardFen(ff);}}catch(e){console.error("Err apply step:",e);}}, [selectedLineIndex, currentMoveInLine, isAnalyzing, analysisPVs, boardFen]);

    // --- Other Functions (sendEngineCommand, performStaticAnalysis, startAnalysis, handleLineSelect, handlePieceDrop, Input Handlers, submitCandidateMove) ---
    const sendEngineCommand=(c)=>{if(worker.current)worker.current.postMessage(c);};
    const performStaticAnalysis=(cF)=>{try{const g=new Chess(cF);const t=g.turn();const o=t==='w'?'b':'w';const a=[];const c=[];SQUARES.forEach(s=>{const p=g.get(s);if(p&&p.color===t&&g.isAttacked(s,o))a.push({square:s,type:p.type,defended:g.isAttacked(s,t)});});CENTER_SQUARES.forEach(cs=>{if(g.isAttacked(cs,t))c.push(cs);});setAttackedPieces(a);setControlledCenterSquares(c);}catch(e){}};
    const startAnalysis=(fen)=>{if(!engineLoaded||!worker.current)return;analyzingFenRef.current=fen;isAnalyzingRef.current=true;isCheckingCandidateResponseRef.current=false;setIsAnalyzing(true);setIsCheckingCandidateResponse(false);setAnalysisPVs([]);setAnalysisEval('');setAnalysisProgress('Starting...');setEngineMessage('Analyzing...');setSelectedLineIndex(null);setCurrentMoveInLine(0);setCandidateMoveInput('');setUserMoveVisualization(null);setOpponentResponses([]);setCandidateMoveError('');sendEngineCommand(`position fen ${fen}`);sendEngineCommand('setoption name MultiPV value 3');sendEngineCommand('go depth 18');};
    const handleLineSelect=(idx)=>{if(isAnalyzing||isCheckingCandidateResponse)return;if(selectedLineIndex===idx){setSelectedLineIndex(null);setCurrentMoveInLine(0);if(analyzingFenRef.current)setBoardFen(analyzingFenRef.current);}else{setSelectedLineIndex(idx);setCurrentMoveInLine(0);if(analyzingFenRef.current)setBoardFen(analyzingFenRef.current);}};
    const handlePieceDrop=(src,tgt)=>{let m=null;try{const g=new Chess(boardFen);m=g.move({from:src,to:tgt,promotion:'q'});if(m===null)return false;const nF=g.fen();setBoardFen(nF);setFenInput(nF);setFenError('');performStaticAnalysis(nF);startAnalysis(nF);return true;}catch(e){return false;}};
    const handleInputChange=(e)=>{setFenInput(e.target.value);if(fenError)setFenError('');};const handleKeyDown=(e)=>{if(e.key==='Enter')validateAndSetFen(fenInput.trim());};const validateAndSetFen=(fen)=>{setIsAnalyzing(false);setIsCheckingCandidateResponse(false);setCandidateMoveInput('');setUserMoveVisualization(null);setOpponentResponses([]);setCandidateMoveError('');try{const g=new Chess(fen);const vF=g.fen();setBoardFen(vF);setFenInput(vF);setFenError('');performStaticAnalysis(vF);startAnalysis(vF);}catch(e){setFenError('Invalid FEN.');setAttackedPieces([]);setControlledCenterSquares([]);}};
    const handleCandidateInputChange=(e)=>{setCandidateMoveInput(e.target.value);if(candidateMoveError)setCandidateMoveError('');};const handleCandidateKeyDown=(e)=>{if(e.key==='Enter'&&candidateMoveInput.trim()){e.preventDefault();submitCandidateMove(candidateMoveInput.trim());}};
    const submitCandidateMove=(moveInput)=>{ if(isAnalyzing||isCheckingCandidateResponse||!engineLoaded)return;setCandidateMoveError('');setUserMoveVisualization(null);setOpponentResponses([]);try{const g=new Chess(boardFen);const mR=g.move(moveInput);if(mR){setUserMoveVisualization({from:mR.from,to:mR.to,san:mR.san});const fenAC=g.fen();fenAfterCandidateRef.current=fenAC;isCheckingCandidateResponseRef.current=true;isAnalyzingRef.current=false;setIsCheckingCandidateResponse(true);setIsAnalyzing(false);setEngineMessage(`Checking opp responses to ${mR.san}...`);sendEngineCommand(`position fen ${fenAC}`);sendEngineCommand('setoption name MultiPV value 2');sendEngineCommand('go movetime 500');}else{setCandidateMoveError(`Invalid: "${moveInput}"`);}}catch(e){setCandidateMoveError(`Err: ${e.message}`);}};

    let turnDisplay='?';try{const g=new Chess(boardFen);turnDisplay=g.turn()==='w'?'White':'Black';}catch(e){} turnDisplay+=' to play';
    const customArrows = []; if(userMoveVisualization){customArrows.push([userMoveVisualization.from, userMoveVisualization.to, 'green']);} opponentResponses.forEach(r=>{const c=(r.isCapture||r.isCheck)?'red':'brown';customArrows.push([r.from,r.to,c]);});

    // --- JSX ---
    return (
        <div className="app-container">
            <div className="board-area"> <Chessboard position={boardFen} onPieceDrop={handlePieceDrop} boardWidth={500} customArrows={customArrows} /><p className="turn-indicator">{turnDisplay}</p></div>
            <div className="analysis-area">
                 <div className="fen-input-container"><label htmlFor="fenInput">FEN:</label><input type="text" id="fenInput" value={fenInput} onChange={handleInputChange} onKeyDown={handleKeyDown} placeholder="Paste/Enter FEN" disabled={isAnalyzing||isCheckingCandidateResponse}/>{fenError && <p className="error-message">{fenError}</p>}</div>
                 <div className="engine-status"><p><strong>Status:</strong> {engineMessage}</p></div>
                 <div className="candidate-move-input-container"><h4>Candidate Move</h4><input type="text" value={candidateMoveInput} onChange={handleCandidateInputChange} onKeyDown={handleCandidateKeyDown} placeholder="e.g., e4, Nf3" disabled={isAnalyzing||isCheckingCandidateResponse||!engineLoaded}/>{candidateMoveError && <p className="error-message">{candidateMoveError}</p>}
                    {isCheckingCandidateResponse && (<p className="opponent-response-loading">Checking...</p>)}
                    {opponentResponses.length > 0 && !isCheckingCandidateResponse && ( <div className="opponent-responses-display"><strong>Opponent Replies:</strong><ul> {opponentResponses.map(r => { const iC=r.isBlunder?'blunder-reply':''; return ( <li key={r.lineId} className={iC}> ({r.score}) {r.san} {(r.isCapture||r.isCheck)&&(<span className={`threat-indicator ${r.isCapture?'capture':''} ${r.isCheck?'check':''}`}> ({r.isCapture?'Cap':''}{r.isCapture&&r.isCheck?'&':''}{r.isCheck?'Chk':''})</span>)}</li>);})}</ul></div>)}
                 </div>
                 <div className="static-analysis"><h4>Static Analysis</h4><div><strong>Attacked:</strong>{attackedPieces.length>0?(<ul>{attackedPieces.map(p=>(<li key={p.square}>{p.type.toUpperCase()}{p.square}(<span className={p.defended?'':'undefended'}>{p.defended?'D':'U'}</span>)</li>))}</ul>):(<p>None</p>)}</div><div><strong>Center Ctrl:</strong>{controlledCenterSquares.length>0?(<p>{controlledCenterSquares.join(', ')}</p>):(<p>None</p>)}</div></div>
                 <div className="analysis-results"><h3>Analysis (Top Lines)</h3>{isAnalyzing&&(<div className="progress-indicator">Analyzing...({analysisProgress})</div>)}{analysisPVs.length > 0 && !isCheckingCandidateResponse && (<div className="pv-lines"><ul>{analysisPVs.map((line, index) => { let dp='(Err)';if(line.start_fen&&line.uci_pv){try{const tG=new Chess(line.start_fen);const uM=line.uci_pv.split(' ');const sM=[];for(const uciM of uM){if(uciM.length>=4&&uciM.length<=5){const mD={from:uciM.substring(0,2),to:uciM.substring(2,4),promotion:uciM.length===5?uciM.substring(4,5):undefined};const mR=tG.move(mD);if(mR)sM.push(mR.san);else{sM.push(`?(${uciM})`);break;}}else{sM.push('?');break;}}dp=sM.join(' ');}catch(e){dp=`${line.uci_pv}(UCI Err)`;}}else if(line.uci_pv){dp=`${line.uci_pv}(UCI FEN?)`;}return(<li key={line.lineId} onClick={()=>handleLineSelect(index)} className={selectedLineIndex===index?'selected-line':''}>({line.score}) {dp}</li>);})}</ul></div>)}{!isAnalyzing&&analysisPVs.length===0&&engineLoaded&&!isCheckingCandidateResponse&&(<p>Analysis appears here.</p>)}</div>
            </div> {/* End analysis-area */}
        </div> // End app-container
    );
}
export default App;